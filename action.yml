# -*- coding: utf-8 -*-
#
#  action.yml
#  Created: 2024/09/15 - 08:10
#  Altered: 2024/10/27 - 12:26
#
#  Copyright (c) 2024-2024, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
name: "Chililinux Package Build Action"
description: "Builds Arch/Chililinux Packages"

inputs:
  build_env:
    description: "Build environment (testing, extra, stable, or aur)"
    required: true
    default: "testing"
  source:
    description: "Custom package repo source"
    required: false
  manjaro_branch:
    description: "Manjaro branch to build"
    default: stable
    required: false
  custom_repo:
    description: "Custom repo"
    required: false
  multilib:
    description: "Build multilib package"
    required: false
    default: "false"
  repo:
    description: "Package repo"
    required: true
  gpg_key:
    description: "GPG signing key"
    required: true
  gpg_passphrase:
    description: "GPG passphrase"
    required: true
  git_branch:
    description: "Extra repository to build package"
    required: false
  extra_command:
    description: "Extra command to run before building"
    required: false
  extra_package:
    description: "Extra package to build"
    required: false
    default: "false"
  tmate:
    description: "Run tmate for debugging"
    required: false
  repo_mirror:
    description: "Mirror to use in build"
    default: repo
    required: false
  repo_dev:
    description: "Development repository"
    required: false
  pacman_mirror:
    description: "Optional: Specific mirror to override automatic selection"
    required: false
  publish_github:
    description: "Publish package on GitHub"
    required: false
    default: "true"
  push_to_repo:
    description: "Push package to repository"
    required: false
    default: "true"
  update_db:
    description: "Update repository database"
    required: false
    default: "true"
  repo_host:
    description: "Repository host"
    required: false
  repo_user:
    description: "Repository user"
    required: false
  repo_port:
    description: "Repository port"
    required: false
  repo_dir:
    description: "Repository directory"
    required: false
  github_token:
    description: "GitHub token for authentication"
    required: true
  telegram_token:
    description: "Telegram bot token for notifications"
    required: false
  telegram_chat_id:
    description: "Telegram chat ID for notifications"
    required: false
  branch_type:
    description: "Branch type (testing or stable)"
    required: true
  url:
    description: "URL do repositório"
    required: false
  new_branch:
    description: "Nome do novo branch"
    required: false
  package_name:
    description: "Nome do pacote"
    required: false
  aur_package_dir:
    description: "Directory containing the AUR package"
    required: false
    default: "."

# Definição dos passos da ação
runs:
  using: "composite"
  steps:
    - name: Define color variables
      id: define_colors
      shell: bash
      run: |
        # Definindo variáveis de cores
        GREEN="\033[01;32m"
        RED="\033[01;31m"
        BLUE="\033[01;34m"
        CYAN="\033[01;36m"
        PINK="\033[01;35m"
        YELLOW="\033[01;33m"
        RESET="\033[0m"

        # Usando as variáveis de cores com printf
        printf "${GREEN}Este é um texto em verde!${RESET}\n"
        printf "${RED}Este é um texto em vermelho!${RESET}\n"
        printf "${BLUE}Este é um texto em azul!${RESET}\n"
        printf "${CYAN}Este é um texto em ciano!${RESET}\n"
        printf "${PINK}Este é um texto em rosa!${RESET}\n"
        printf "${YELLOW}Este é um texto em amarelo!${RESET}\n"

    - name: Inicializando criação de pacote
      shell: bash
      run: |
        # Function to send Telegram message
        send_telegram_message() {
          message="$1"
          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
            -d chat_id="${{ inputs.telegram_chat_id }}" \
            -d text="$message"\
            -d parse_mode="MarkdownV2"
        }
        pkgname="${{ inputs.package_name }}"
        branch="${{ inputs.branch_type }}"
        repositorio="${{ inputs.repo_dir }}"
        pkgname_escaped=$(echo "$pkgname" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
        branch_escaped=$(echo "${branch^^}" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
        send_telegram_message "⭐ **\[step 1/3\] Iniciando criação de pacote**%0A"\
        "**nome:** \`$pkgname_escaped\`%0A"\
        "**url:** \`$repositorio\`%0A"\
        "**repositório:** \`$branch_escaped\`"

    - name: Setup build environment
      shell: bash
      run: |
        sudo pacman -Syu --quiet --needed --noconfirm \
          base-devel \
          cmake \
          libarchive \
          meson \
          ninja \
          yay \
          tmate \
          duf \
          curl \
          tree

    - name: Setup TMATE Session
      uses: mxschmitt/action-tmate@v3
      #if: ${{ github.event.client_payload.tmate == true || inputs.tmate == true}}
      with:
        install-dependencies: false
        detached: true

    - name: Import GPG key
      shell: bash
      run: |
        # Import GPG key
        if gpg --batch --import <<< "${{ inputs.gpg_key }}"; then
          echo -e "\033[01;32m=>Importação da chave GPG foi bem-sucedida. ${RESET}"
        else
          echo -e "\033[01;31m=>Erro na importação da chave GPG. ${RESET}"
          exit 1
        fi

    - name: Configure System and Repositories
      shell: bash
      run: |
        # Set up pacman mirror
        echo "Usando mirror especificado: ${{ inputs.pacman_mirror }}"
        echo 'Server = ${{ inputs.pacman_mirror }}' | sudo tee /etc/pacman.d/mirrorlist

        # Remove existing BigLinux repositories
        sudo sed -i '/biglinux/,$d' /etc/pacman.conf

        # Add appropriate repositories based on build environment
        if [ "${{ inputs.build_env }}" == "testing" ] || [ "$BRANCH_TYPE" == "testing" ]; then
          echo '
          [community-testing]
          SigLevel = PackageRequired
          Server = https://repo.communitybig.org/testing/$arch

          [biglinux-testing]
          SigLevel = PackageRequired
          Server = https://repo.biglinux.com.br/testing/$arch

          [biglinux-stable]
          SigLevel = PackageRequired
          Server = https://repo.biglinux.com.br/stable/$arch' | sudo tee -a /etc/pacman.conf /etc/chrootbuild/pacman.conf.x86_64
        elif [ "${{ inputs.build_env }}" == "extra" ] || [ "$BRANCH_TYPE" == "extra" ]; then
          echo '
          [community-extra]
          SigLevel = PackageRequired
          Server = https://repo.communitybig.org/extra/$arch' | sudo tee -a /etc/pacman.conf /etc/chrootbuild/pacman.conf.x86_64
        elif [ "${{ inputs.build_env }}" == "stable" ] || [ "$BRANCH_TYPE" == "stable" ]; then
          echo '
          [community-stable]
          SigLevel = PackageRequired
          Server = https://repo.communitybig.org/stable/$arch

          [biglinux-stable]
          SigLevel = PackageRequired
          Server = https://repo.biglinux.com.br/stable/$arch' | sudo tee -a /etc/pacman.conf /etc/chrootbuild/pacman.conf.x86_64
        elif [ "${{ inputs.build_env }}" == "aur" ] || [ "${{ inputs.branch_type }}" == "aur" ]; then
          echo "Configurando para pacote AUR: ${{ inputs.package_name }}"
          # Configurações específicas para AUR
          sudo sed -i 's/^#MAKEFLAGS="-j2"/MAKEFLAGS="-j$(nproc)"/' /etc/makepkg.conf
          sudo sed -i 's/^#BUILDDIR/BUILDDIR/' /etc/makepkg.conf
          sudo sed -i 's/^#PKGDEST/PKGDEST/' /etc/makepkg.conf

          # Habilitar o repositório multilib (necessário para alguns pacotes AUR)
          sudo sed -i '/\[multilib\]/,/Include/s/^#//' /etc/pacman.conf

          # Atualizar os repositórios após as mudanças
          sudo pacman -Sy

          # Instalar dependências comumente necessárias para builds AUR
          sudo pacman -S --needed base-devel git --noconfirm
        else
          echo "Invalid branch type specified: ${{ inputs.branch_type }}"
          exit 1
        fi

        # Configure makepkg
        sudo sed -i '/PACKAGER=/s/.*/PACKAGER="Vilmar Catafesta <vcatafesta@gmail.com>"/' /etc/makepkg.conf
        sudo sed -i '/MAKEFLAGS=/s/.*/MAKEFLAGS="-j'$(nproc)'"/' /etc/makepkg.conf
        sudo sed -i '/GPGKEY=/s/.*/GPGKEY="A0D5A8312A83940ED8B04B0F4BAC871802E960F1"/; t; $a GPGKEY="A0D5A8312A83940ED8B04B0F4BAC871802E960F1"' /etc/makepkg.conf

        # Modify manjaro-chrootbuild
        sudo sed -i 's|https://repo.manjaro.org/repo|https://nnenix.mm.fcix.net/manjaro|' /usr/lib/manjaro-chrootbuild/util.sh
        sudo sed -i '/-Syy/s/-Syy/-Syy git /' /usr/lib/manjaro-chrootbuild/util-chroot.sh

    # Download the source code
    - name: Download Source
      shell: bash
      run: |
        if [ "${{ inputs.build_env }}" == "aur" ]; then
          echo "Cloning AUR package from ${{ inputs.url }}"
          git clone ${{ inputs.url }} aur_package
          if [ -d "aur_package" ]; then
            cd aur_package
            if [ ! -f "PKGBUILD" ]; then
              echo "Error: PKGBUILD not found in the AUR package"
              exit 1
            fi
          else
            echo "Error: Failed to clone AUR package"
            exit 1
          fi
        elif [ -n "${{ inputs.url }}" ]; then
          echo "Cloning repository from ${{ inputs.url }}"
          git clone ${{ inputs.url }}.git source_repo
          cd source_repo
          if [ -n "${{ inputs.git_branch }}" ]; then
            echo "Checking out branch ${{ inputs.git_branch }}"
            git checkout ${{ inputs.git_branch }}
          fi
        else
          echo "No URL provided, assuming we're already in the correct repository"
        fi

        # Debug: Show current directory and contents
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la

    # Constrói o pacote
    - name: Build package
      shell: bash
      run: |
        set -ex  # Isso fará o script falhar se qualquer comando falhar
        # Debug: Mostrar ambiente de build
        echo "Build environment: ${{ inputs.build_env }}"
        echo "Package name: ${{ inputs.package_name }}"

         # Se entramos em um diretório no passo anterior, vamos garantir que estamos nele
        if [ -d "source_repo" ]; then
          cd source_repo
        fi

        # Debug: Mostrar diretório atual e conteúdo
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la

        # Create and set permissions for $PKGDEST and $SRCDEST
        sudo mkdir -p /home/packages /home/sources
        sudo chown builduser:builduser /home/packages /home/sources

        if [ "${{ inputs.build_env }}" == "aur" ]; then
          # Para pacotes AUR
          cd ${{ inputs.aur_package_dir }}
          echo "Construindo pacote AUR: ${{ inputs.package_name }}"
          echo "Current AUR package directory: $(pwd)"
          echo "AUR package directory contents:"
          ls -la

          # Give permissions to builduser for the current directory
          sudo chown -R builduser:builduser .

          # Criar diretório temporário para makepkg
          sudo mkdir -p /tmp/makepkg
          sudo chown builduser:builduser /tmp/makepkg

          # Extrair dependências do PKGBUILD
          depends=$(grep -E "^depends=\(" PKGBUILD | sed 's/depends=(//' | sed 's/)$//' | tr -d "'")
          makedepends=$(grep -E "^makedepends=\(" PKGBUILD | sed 's/makedepends=(//' | sed 's/)$//' | tr -d "'")

          # Instalar dependências
          echo "Installing dependencies..."
          sudo yay -Sy --asdeps --nodeps $depends $makedepends --noconfirm

          # Construir o pacote sem instalar
          echo "Building AUR package: ${{ inputs.package_name }}"
          makepkg -s --noconfirm --noprogressbar --nodeps

          # Mover o pacote compilado para /home/packages
          mv *.pkg.tar.zst /home/packages/ 2>/dev/null || echo 'No package found to move'

          echo "Build completed. Checking /home/packages:"
          ls -la /home/packages
        else
          # Para pacotes não-AUR
          gitfolder=$(find . -name "PKGBUILD" -exec dirname {} \;)
          cd $gitfolder

          make_with_makepkg() {
            makepkg -s --noconfirm --nodeps
          }

          make_with_chrootbuild() {
            # Ensure architecture is set to x86_64
            sed -i "/^arch=/c\arch=('x86_64')" PKGBUILD
            # Build for x86_64
            echo -e "\033[01;31mBuild x86_64\033[0m"
            # Determinar o branch de build
            if [ "${{ inputs.build_env }}" == "extra" ]; then
              build_branch="testing"
              echo "Ambiente de build é 'extra', usando branch 'testing' para chrootbuild"
            else
              build_branch="${{ inputs.branch_type }}"
            fi

            # Executar chrootbuild com o branch determinado
            sudo chrootbuild -H -p . -b ${build_branch}
          }
          make_with_makepkg
        fi

        # Executa comando extra, se fornecido
        if [ -n "${{ inputs.extra_command }}" ]; then
          echo "Executando comando extra: ${{ inputs.extra_command }}"
          ${{ inputs.extra_command }}
        fi

        # Debug: Mostrar conteúdo do diretório após o build
        echo "Directory contents after build:"
        ls -la
        echo "Contents of /home/packages:"
        ls -la /home/packages
        echo "Contents of /home/sources:"
        ls -la /home/sources

    # Assina o pacote
    - name: Sign Package
      shell: bash
      run: |
        # Sign Package
        ls -lah
        if [ "${{ inputs.build_env }}" == "aur" ]; then
          # Para pacotes AUR
          cd /home/packages
        else
          # Para pacotes não-AUR
          gitfolder=$(find . -name "*.zst" -exec dirname {} \;)
          if [ -z "$gitfolder" ]; then
            echo "Arquivo de pacote '.zst' não encontrado. Usando diretório atual."
            gitfolder="."
          fi
          cd "$gitfolder"
        fi

        ls -lah
        # Assina todos os pacotes encontrados
        # Import GPG key
        if gpg --batch --import <<< "${{ inputs.gpg_key }}"; then
          echo -e "\033[01;32m=>Importação da chave GPG foi bem-sucedida. ${RESET}"
        else
          echo -e "\033[01;31m=>Erro na importação da chave GPG. ${RESET}"
          exit 1
        fi

        for p in *.zst; do
          echo -e "\033[01;36mAssinando pacote: $p ${RESET}"
          gpg --pinentry-mode loopback --passphrase "${{ inputs.gpg_passphrase }}" --detach-sign "${p}"
        done

        # Lista os arquivos .sig gerados
        echo "Arquivos de assinatura gerados:"
        ls -lah *.sig* || echo "Nenhum arquivo .sig encontrado"

    # Gera checksums para os pacotes
    - name: Generate checksums
      shell: bash
      run: |
        if [ "${{ inputs.build_env }}" == "aur" ]; then
          # Para pacotes AUR
          cd /home/packages
        else
          # Para pacotes não-AUR
          gitfolder=$(find . -name "*.zst" -exec dirname {} \;)
          if [ -z "$gitfolder" ]; then
            echo "Arquivo de pacote '.zst' não encontrado. Usando diretório atual."
            gitfolder="."
          fi
          cd "$gitfolder"
        fi

        # Gera checksums para pacotes e assinaturas
        for i in *.pkg.tar.zst; do
          if [[ -f "$i" ]]; then
            echo -e "\033[01;36mGerado MD5 para: $i ${RESET}"
            md5sum "$i"     >> "$i.md5"
            md5sum "$i.sig" >> "$i.sig.md5"
            echo -e "\033[01;36mMD5 gerado para: $i ${RESET}"
          fi
        done

        # Lista os arquivos MD5 gerados
        echo "Arquivos MD5 gerados:"
        ls -l *.md5 || echo "Nenhum arquivo MD5 encontrado"

    # Publish the package on GitHub
    - name: Publish Package on GitHub
      if: inputs.publish_github == 'true' && inputs.build_env != 'aur'
      shell: bash
      run: |
        gitfolder=$(find . -name "*.zst" -exec dirname {} \;)
        cd $gitfolder
        ls -lh

        # Skip linux-zen packages
        if [ -n "$(grep linux-zen <<< $gitfolder)" ];then
          exit 0
        fi

        # Determine the last committer
        lastCommit=$(git log -1 --format="%an <%ae>")
        if [ "$(grep github-actions <<< $lastCommit)" ];then
          lastCommit=$(git log -2 --format="%an <%ae>")
        fi

        # Set up GitHub authentication and determine the repository
        if [ -n "${{ inputs.url }}" ]; then
          echo "${{ inputs.github_token }}" | gh auth login --with-token
          repo=$(echo "${{ inputs.url }}" | sed 's|https://github.com/||')
        else
          echo "${{ inputs.github_token }}" | gh auth login --with-token
          repo="${{ inputs.repo }}"
        fi

        # Fallback to github.repository if repo is still empty
        if [ -z "$repo" ]; then
          repo="${{ github.repository }}"
        fi

        # Create and upload the release
        ls *.pkg* | head -n1 | sed 's/.pkg.*//' > release
        release=$(cat release)

        echo "release=$release"
        echo "repo=$repo"
        echo "url=${{ inputs.url }}"

        if [ -n "$repo" ] && [ -n "$release" ]; then
          echo "Using repository: $repo"
          echo "Creating release: $release"
          gh release create ${release} --title ${release} --repo ${repo} --notes "automated release from ${{ inputs.url }}" || echo "release already exists"
          for i in .zst .sig .tar .md5; do
            find -iname "*$i" -exec gh release upload ${release} --repo ${repo} --clobber {} \;
          done
        else
          echo "Error: repo or release is empty"
          exit 1
        fi

    # Push the package to the repository
    - name: Push to Repo
      if: inputs.push_to_repo == 'true'
      shell: bash
      env:
        LANG: en_US.UTF-8
        LC_ALL: en_US.UTF-8
      run: |
        # Setup SSH
        mkdir -p /home/builduser/.ssh
        ssh-keyscan -t rsa -p ${{ inputs.repo_port }} ${{ inputs.repo_host }} >> /home/builduser/.ssh/known_hosts
        ip=${{ inputs.repo_host }}

        if [ "${{ inputs.build_env }}" == "aur" ]; then
          # Para pacotes AUR
          cd /home/packages
          branch="TESTING"  # Todos os pacotes AUR vão para TESTING
        else
          # Para pacotes não-AUR
          gitfolder=$(find . -name "*.zst" -exec dirname {} \;)
          cd $gitfolder

          # Determine the last committer (apenas para pacotes não-AUR)
          lastCommit=$(git log -1 --format="%an <%ae>")
          if [ "$(grep github-actions <<< $lastCommit)" ];then
            lastCommit=$(git log -2 --format="%an <%ae>")
          fi

          # Set the branch based on BRANCH_TYPE
          if [ "${{ inputs.branch_type }}" == "stable" ]; then
            branch="STABLE"
          elif [ "${{ inputs.branch_type }}" == "extra" ]; then
            branch="EXTRA"
          else
            branch="TESTING"
          fi
        fi

        ls -lh

        # Function to send Telegram message
        send_telegram_message() {
          message="$1"
          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
            -d chat_id="${{ inputs.telegram_chat_id }}" \
            -d text="$message"\
            -d parse_mode="MarkdownV2"
        }

        # Upload the package files
        for i in *.pkg.tar.zst; do
          pkgname=$(basename $i)
          pkgname_escaped=$(echo "$pkgname" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
          branch_escaped=$(echo "$branch" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
          file_size_bytes=$(stat -c%s "$i")

          echo "Pacote $pkgname sendo enviado para o repositório ${branch,,}"
          #send_telegram_message "📦 **\[step 2/3\] Enviando pacote para o repositório**%0A**nome         : ** \`$pkgname_escaped\`%0A**repositório : ** \`$branch_escaped\`"
          send_telegram_message "📦 **\[step 2/3\] Enviando pacote para o repositório**%0A**nome         : ** \`$pkgname_escaped\`%0A**tamanho bytes: ** \`$file_size_bytes\`%0A**repositório  : ** \`$branch_escaped\`"

          if rsync -vapz -e "ssh -p ${{ inputs.repo_port }}" $i ${{ inputs.repo_user }}@$ip:${{ inputs.repo_dir }}/${branch,,}/x86_64/; then
            send_telegram_message "✅ **\[step 3/3\] Pacote enviado com sucesso**%0A**nome         : ** \`$pkgname_escaped\`%0A**repositório : ** \`$branch_escaped\`"
          else
            send_telegram_message "❌ **\[step 3/3\] Falha ao enviar pacote**%0A**nome         : ** \`$pkgname_escaped\`%0A**repositório : ** \`$branch_escaped\`"
          fi
        done

        for i in *.sig *.md5; do
          #rsync -vapz -e "ssh -p ${{ inputs.repo_port }}" $i ${{ inputs.repo_user }}@$ip:${{ inputs.repo_dir }}
          rsync -vapz -e "ssh -p ${{ inputs.repo_port }}" $i ${{ inputs.repo_user }}@$ip:${{ inputs.repo_dir }}/${branch,,}/x86_64/
        done

    # Keeps only the most recent package
    - name: Clean Old Packages
      if: inputs.update_db == 'true' && success()
      shell: bash
      run: |
        # Function to send Telegram message
        send_telegram_message() {
          message="$1"
          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
            -d chat_id="${{ inputs.telegram_chat_id }}" \
            -d text="$message" \
            -d parse_mode="MarkdownV2"
        }

        # Determine the branch based on the branch type
        if [ "${{ inputs.branch_type }}" == "stable" ]; then
          branch="STABLE"
          db_name="chili-stable"
        elif [ "${{ inputs.branch_type }}" == "extra" ]; then
          branch="EXTRA"
          db_name="chili-extra"
        elif [ "${{ inputs.branch_type }}" == "aur" ] || [ "${{ inputs.branch_type }}" == "testing" ]; then
          branch="TESTING"
          db_name="chili-testing"
        else
          echo "Error: Unknown branch type: ${{ inputs.branch_type }}"
          exit 1
        fi

        echo "Branch       : $branch"
        echo "Database name: $db_name"

        branch_escaped=$(echo "$branch" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')

        echo "🧹 Limpando pacotes antigos no repositório $branch..."
        send_telegram_message "🧹 **Iniciando limpeza de pacotes antigos no repositório** \`$branch_escaped\`"

        ssh ${{ inputs.repo_user }}@${{ inputs.repo_host }} -p ${{ inputs.repo_port }} << EOF
          set -x
          cd ${{ inputs.repo_dir }}/${branch,,}/x86_64

          ## Manter apenas a versão mais recente de cada pacote
          #for pkg in $(ls *.pkg.tar.zst | cut -d- -f1 | sort -u); do
          #  newest=\$(ls \${pkg}-*.pkg.tar.zst | sort -V | tail -n1)
          #  for old in \${pkg}-*.pkg.tar.zst; do
          #    if [ "\$old" != "\$newest" ]; then
          #      echo "Removing old package: \$old"
          #      rm -f "\$old" "\${old}.sig" "\${old}.md5"
          #    fi
          #  done
          #done

          # Manter apenas a versão mais recente de cada pacote
          FETCH_RE='-[^-]+[0-9]+[^.]*.pkg[^.]*.tar.zst'
          PKG_EXT='pkg.tar.zst'
          AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort -Vr | awk -F "$FETCH_RE" 'lista[$1]++')
          for old in ${AllOldPackages[@]}; do
            echo "Removing old package: $((++count)), $old"
            rm -f "${old}"
            rm -f "${old}.sig"
            rm -f "${old}.md5"
            rm -f "${old}.sig.md5"
          done

          # Remover os bancos de dados existentes
          #rm -f $db_name.db.tar.gz $db_name.files.tar.gz

          # Recriar o banco de dados com os pacotes presentes
          #repo-add $db_name.db.tar.gz *.pkg.tar.zst

          # Remover arquivos .sig e .md5 órfãos
          for file in *.sig *.md5; do
            base_name=\${file%.*}
            if [ ! -f "\${base_name}" ]; then
              echo "Removing orphaned file: \$file"
              rm -f "\$file"
            fi
          done
          exit_code=\$?
          echo "Limpeza concluída com código de saída: \$exit_code"
          exit \$exit_code
        EOF

        if [ $? -eq 0 ]; then
          echo "✅ Limpeza de pacotes antigos concluída com sucesso!"
          send_telegram_message "✅ **Limpeza de pacotes antigos no repositório** \`$branch_escaped\` **concluída com sucesso\!**"
        else
          echo "❌ Falha na limpeza de pacotes antigos."
          send_telegram_message "❌ **Falha na limpeza de pacotes antigos no repositório** \`$branch_escaped\`\."
        fi

#    # Runs only if previous steps were successful
#    - name: Update Repository Database
#      if: inputs.update_db == 'true' && success()
#      shell: bash
#      run: |
#        # Function to send Telegram message
#        send_telegram_message() {
#          message="$1"
#          curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
#            -d chat_id="${{ inputs.telegram_chat_id }}" \
#            -d text="$message" \
#            -d parse_mode="MarkdownV2"
#        }
#
#        # Determine the database name based on the branch type
#        if [ "${{ inputs.branch_type }}" == "stable" ]; then
#          branch="STABLE"
#          db_name="chili-stable"
#        elif [ "${{ inputs.branch_type }}" == "extra" ]; then
#          branch="EXTRA"
#          db_name="chili-extra"
#        elif [ "${{ inputs.branch_type }}" == "aur" ] || [ "${{ inputs.branch_type }}" == "testing" ]; then
#          branch="TESTING"
#          db_name="chili-testing"
#        else
#          echo "Error: Unknown branch type: ${{ inputs.branch_type }}"
#          exit 1
#        fi
#
#        echo "Branch: $branch"
#        echo "Database name: $db_name"
#
#        branch_escaped=$(echo "$branch" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
#        db_name_escaped=$(echo "$db_name" | sed 's/[_*[\]()~`>#+\-=|{}.!]/\\&/g')
#
#        echo "🔄 Sincronizando o banco de dados do repositório $branch..."
#        #send_telegram_message "🔄 **Iniciando sincronização do banco de dados do repositório** \`$branch_escaped\`"
#
#        ssh -v ${{ inputs.repo_user }}@${{ inputs.repo_host }} -p ${{ inputs.repo_port }} << EOF
#          set -x
#          cd ${{ inputs.repo_dir }}/${branch,,}/x86_64
#          repo-add -n -R $db_name.db.tar.gz *.pkg.tar.zst
#          exit_code=\$?
#          echo "Comando repo-add concluído com código de saída: \$exit_code"
#          exit \$exit_code
#        EOF
#
#        if [ $? -eq 0 ]; then
#          echo "✅ Sincronização do banco de dados concluída com sucesso!"
#          send_telegram_message "✅ **Sincronização do banco de dados do repositório** \`$branch_escaped\` **concluída com sucesso\!**"
#        else
#          echo "❌ Falha na sincronização do banco de dados."
#          send_telegram_message "❌ **Falha na sincronização do banco de dados do repositório** \`$branch_escaped\`\."
#        fi
#
#    # Send a Telegram alert if the build fails
#    - name: Telegram Alert Fail
#      if: failure()
#      shell: bash
#      run: |
#        curl -s -X POST "https://api.telegram.org/bot${{ inputs.telegram_token }}/sendMessage" \
#          -d chat_id="${{ inputs.telegram_chat_id }}" \
#          -d text="🚨 FALHA ao criar Pacote: ${{ github.event.action }} a partir do branch ${{ github.ref_name }}, link do erro: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }} 🖥"
